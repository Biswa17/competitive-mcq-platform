<?php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Exam; // Import the Exam model
use App\Models\Question;
use App\Models\Topic;
use Illuminate\Support\Facades\Http; // Use Laravel's HTTP client
use Illuminate\Support\Facades\Log; // Use Laravel's Log facade
use Illuminate\Support\Facades\DB; // For potential future use like transactions or checks

class QuestionSeeder extends Seeder
{
    public function run(): void
    {
        $this->command->info('Starting Question Seeder...');

        // Get all exams
        $exams = Exam::with('topics')->get(); // Eager load topics for efficiency

        if ($exams->isEmpty()) {
            $this->command->warn('No exams found in the database. Exiting Question Seeder.');
            return;
        }

        // Loop through each exam
        foreach ($exams as $exam) {
            $this->command->info("Processing Exam: {$exam->name} (ID: {$exam->id})");

            $topics = $exam->topics; // Access eager-loaded topics

            if ($topics->isEmpty()) {
                $this->command->warn("  No topics found for Exam '{$exam->name}'. Skipping.");
                continue;
            }

            // Loop through topics for the current exam
            foreach ($topics as $topic) {
                $this->command->info("  Processing Topic: {$topic->name} (ID: {$topic->id})");

                try {
                    $generatedQuestions = $this->getQuestionsFromApi($topic->name);

                    if (empty($generatedQuestions)) {
                        $this->command->warn("    No questions generated or retrieved for Topic '{$topic->name}'.");
                        continue; // Move to the next topic
                    }

                    $this->processGeneratedQuestions($generatedQuestions, $topic, $exam);

                } catch (\Exception $e) {
                    $this->command->error("    Error processing Topic '{$topic->name}' (ID: {$topic->id}). Error: " . $e->getMessage());
                    Log::error("Error seeding questions for Topic ID {$topic->id}, Exam ID {$exam->id}: " . $e->getMessage(), ['exception' => $e]);
                } // End try-catch block
            } // End topic loop
        } // End exam loop

        $this->command->info('Question Seeder finished.');
    }

    /**
     * Process the questions generated by the API for a specific topic and exam.
     *
     * @param array $generatedQuestions
     * @param Topic $topic
     * @param Exam $exam
     * @return void
     */
    private function processGeneratedQuestions(array $generatedQuestions, Topic $topic, Exam $exam): void
    {
        foreach ($generatedQuestions as $questionData) {
            // Validate required fields from API response
            if (!isset($questionData['question_text'], $questionData['option_a'], $questionData['option_b'], $questionData['option_c'], $questionData['option_d'], $questionData['correct_option'])) {
                $this->command->error("    Skipping invalid question data for Topic '{$topic->name}'. Missing fields.");
                Log::warning("Invalid question data received from API for topic '{$topic->name}': ", $questionData);
                continue; // Skip this question data
            }

            // Check if the question already exists for this specific topic and exam
            $exists = Question::where('question_text', $questionData['question_text'])
                ->where('topic_id', $topic->id)
                ->where('exam_id', $exam->id)
                ->exists();

            if (!$exists) {
                Question::create([
                    'question_text' => $questionData['question_text'],
                    'option_a' => $questionData['option_a'],
                    'option_b' => $questionData['option_b'],
                    'option_c' => $questionData['option_c'],
                    'option_d' => $questionData['option_d'],
                    'correct_option' => $questionData['correct_option'],
                    'topic_id' => $topic->id,
                    'exam_id' => $exam->id,
                    'question_paper_id' => null, // Keep this null for topic-based questions
                ]);
                $this->command->info("      Created question for Topic '{$topic->name}', Exam '{$exam->name}'");
            } else {
                 $this->command->line("      Question already exists for Topic '{$topic->name}', Exam '{$exam->name}'. Skipping.");
            }
        }
    }

    /**
     * Fetches questions from the Generative Language API for a given topic.
     * Includes basic retry logic.
     *
     * @param string $topicName
     * @param int $retryCount
     * @return array|null
     */
    private function getQuestionsFromApi(string $topicName, int $retryCount = 3): ?array
    {
        $apiKey = env('GEMINI_API_KEY');
        if (!$apiKey) {
            $this->command->error('GEMINI_API_KEY is not set in the .env file.');
            Log::error('GEMINI_API_KEY is not set.');
            return null; // Cannot proceed without API key
        }

        $url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key={$apiKey}"; // Updated model

        $prompt = "Generate 10 multiple-choice questions (MCQs) on the topic '$topicName'.
                 Provide the response ONLY as a valid JSON array adhering strictly to this structure:
                 [
                     {
                         \"question_text\": \"<The question text>\",
                         \"option_a\": \"<Option A text>\",
                         \"option_b\": \"<Option B text>\",
                         \"option_c\": \"<Option C text>\",
                         \"option_d\": \"<Option D text>\",
                         \"correct_option\": \"<A, B, C, or D>\"
                     }
                 ]
                 Do not include any introductory text, explanations, markdown formatting (like ```json), or anything outside the JSON array itself.";

        $postData = [
            "contents" => [["parts" => [["text" => $prompt]]]],
            // Optional: Add safety settings if needed
            // "safetySettings" => [ ... ],
            "generationConfig" => [
                "responseMimeType" => "application/json", // Request JSON directly
                "temperature" => 0.7 // Adjust creativity/predictability
            ]
        ];

        for ($attempt = 1; $attempt <= $retryCount; $attempt++) {
            try {
                $response = Http::timeout(60)->post($url, $postData); // Use Laravel HTTP client, 60s timeout

                if ($response->successful() && $response->json('candidates.0.content.parts.0.text')) {
                    $aiGeneratedText = trim($response->json('candidates.0.content.parts.0.text'));

                    // Basic cleanup, though responseMimeType should help
                    $aiGeneratedText = preg_replace('/^```json\s*|```\s*$/', '', $aiGeneratedText);

                    $questions = json_decode($aiGeneratedText, true);

                    if (json_last_error() === JSON_ERROR_NONE && is_array($questions)) {
                        $this->command->info("      Successfully retrieved and decoded questions for '{$topicName}'.");
                        return $questions;
                    } else {
                        $this->command->warn("      JSON decoding failed for '{$topicName}'. Attempt {$attempt}/{$retryCount}. Error: " . json_last_error_msg());
                        Log::warning("JSON decoding failed for topic '{$topicName}'.", [
                            'attempt' => $attempt,
                            'error' => json_last_error_msg(),
                            'raw_response' => $aiGeneratedText
                        ]);
                    }
                } else {
                    $this->command->warn("      API request failed for '{$topicName}'. Status: {$response->status()}. Attempt {$attempt}/{$retryCount}.");
                    Log::warning("API request failed for topic '{$topicName}'.", [
                        'attempt' => $attempt,
                        'status' => $response->status(),
                        'response_body' => $response->body()
                    ]);
                }

            } catch (\Illuminate\Http\Client\ConnectionException $e) {
                 $this->command->error("      Connection error during API call for '{$topicName}'. Attempt {$attempt}/{$retryCount}. Error: " . $e->getMessage());
                 Log::error("Connection error for topic '{$topicName}'.", ['attempt' => $attempt, 'exception' => $e]);
            } catch (\Exception $e) {
                 $this->command->error("      An unexpected error occurred during API call for '{$topicName}'. Attempt {$attempt}/{$retryCount}. Error: " . $e->getMessage());
                 Log::error("Unexpected error during API call for topic '{$topicName}'.", ['attempt' => $attempt, 'exception' => $e]);
            }

            if ($attempt < $retryCount) {
                $this->command->line("      Retrying in 10 seconds...");
                sleep(10); // Wait before retrying
            }
        }

        $this->command->error("      Failed to retrieve valid questions for '{$topicName}' after {$retryCount} attempts.");
        return null; // Return null after all retries fail
    }
}
